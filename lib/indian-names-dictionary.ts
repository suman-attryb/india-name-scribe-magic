// Common Indian first names
export const INDIAN_FIRST_NAMES = new Set([
  // Male names
  "Aarav",
  "Aditya",
  "Akash",
  "Amit",
  "Anand",
  "Ankit",
  "Arjun",
  "Ashish",
  "Deepak",
  "Dev",
  "Gaurav",
  "Harsh",
  "Karan",
  "Krishna",
  "Manish",
  "Nikhil",
  "Pradeep",
  "Rahul",
  "Raj",
  "Rajesh",
  "Ravi",
  "Rohit",
  "Sachin",
  "Sanjay",
  "Shivam",
  "Suresh",
  "Vikash",
  "Vinay",
  "Vivek",
  "Abhishek",
  "Ajay",
  "Aman",
  "Amitabh",
  "Anil",
  "Anirudh",
  "Aryan",
  "Bharat",
  "Chandan",
  "Dhruv",
  "Gopal",
  "Hari",
  "Hemant",
  "Jatin",
  "Kunal",
  "Manoj",
  "Mohit",
  "Naveen",
  "Pankaj",
  "Prakash",
  "Raghav",
  "Ramesh",
  "Ritesh",
  "Shubham",
  "Sumit",
  "Tarun",
  "Varun",
  "Yash",
  "Abhay",
  "Abhinav",
  "Adarsh",
  "Advait",
  "Akshay",
  "Alok",
  "Amol",
  "Anuj",
  "Arpit",
  "Ashwin",
  "Atul",
  "Avinash",
  "Bhushan",
  "Chirag",
  "Darshan",
  "Dhanush",
  "Dinesh",
  "Girish",
  "Hardik",
  "Hitesh",
  "Jagdish",
  "Jayesh",
  "Kailash",
  "Kartik",
  "Kiran",
  "Lalit",
  "Mahesh",
  "Mukesh",
  "Naresh",
  "Nitin",
  "Paresh",
  "Pranav",
  "Puneet",
  "Rajeev",
  "Rakesh",
  "Rohan",
  "Sagar",
  "Sandeep",
  "Santosh",
  "Shailesh",
  "Shankar",
  "Shyam",
  "Subhash",
  "Sunil",
  "Surya",
  "Tushar",
  "Umesh",
  "Vijay",
  "Vikas",
  "Vishal",

  // Female names
  "Aadhya",
  "Ananya",
  "Anjali",
  "Anushka",
  "Arpita",
  "Deepika",
  "Divya",
  "Kavya",
  "Meera",
  "Neha",
  "Pooja",
  "Priya",
  "Riya",
  "Shreya",
  "Sneha",
  "Swati",
  "Tanvi",
  "Vani",
  "Vidya",
  "Aditi",
  "Aishwarya",
  "Akanksha",
  "Amrita",
  "Archana",
  "Bhavana",
  "Geeta",
  "Isha",
  "Jyoti",
  "Kiran",
  "Lakshmi",
  "Madhuri",
  "Nandini",
  "Pallavi",
  "Radha",
  "Rashmi",
  "Rekha",
  "Sapna",
  "Shilpa",
  "Sita",
  "Sunita",
  "Usha",
  "Vandana",
  "Yamini",
  "Aarti",
  "Alka",
  "Anita",
  "Asha",
  "Bharti",
  "Chitra",
  "Deepti",
  "Gayatri",
  "Heena",
  "Indira",
  "Jaya",
  "Kalpana",
  "Kavita",
  "Lata",
  "Mamta",
  "Nisha",
  "Poonam",
  "Preeti",
  "Rajni",
  "Renu",
  "Sarita",
  "Seema",
  "Shanti",
  "Sonal",
  "Sushma",
  "Tara",
  "Uma",
  "Veena",
  "Vinita",
  "Yogita",

  // South Indian names
  "Arun",
  "Balaji",
  "Ganesh",
  "Harish",
  "Jagannath",
  "Karthik",
  "Mahesh",
  "Nagaraj",
  "Prasad",
  "Raman",
  "Srinivas",
  "Subramaniam",
  "Venkatesh",
  "Anitha",
  "Bharathi",
  "Chandra",
  "Devi",
  "Geetha",
  "Kamala",
  "Latha",
  "Malathi",
  "Nirmala",
  "Padma",
  "Radhika",
  "Sita",
  "Sudha",
  "Usha",
  "Vasantha",

  // Unisex names
  "Arpit",
  "Avni",
  "Daksh",
  "Ishaan",
  "Jaya",
  "Kiran",
  "Naman",
  "Pari",
  "Rishi",
  "Sagar",
  "Tara",
  "Veer",
])

export const INDIAN_LAST_NAMES = new Set([
  "Agarwal",
  "Aggarwal",
  "Ahuja",
  "Bansal",
  "Bhatia",
  "Chopra",
  "Garg",
  "Goyal",
  "Gupta",
  "Jain",
  "Jindal",
  "Kapoor",
  "Malhotra",
  "Mittal",
  "Sharma",
  "Singhal",
  "Sood",
  "Tandon",
  "Tiwari",
  "Verma",
  "Bhardwaj",
  "Chandra",
  "Chauhan",
  "Chawla",
  "Dua",
  "Goel",
  "Joshi",
  "Khurana",
  "Kumar",
  "Mahajan",
  "Mehra",
  "Mishra",
  "Nair",
  "Pandey",
  "Patel",
  "Rao",
  "Reddy",
  "Sahu",
  "Saxena",
  "Shah",
  "Shukla",
  "Singh",
  "Sinha",
  "Srivastava",
  "Thakur",
  "Tripathi",
  "Yadav",
  "Iyer",
  "Iyengar",
  "Krishnan",
  "Menon",
  "Nambiar",
  "Pillai",
  "Raman",
  "Subramanian",
  "Swamy",
  "Venkatesh",
  "Acharya",
  "Bhat",
  "Hegde",
  "Kamath",
  "Kulkarni",
  "Naik",
  "Pai",
  "Rao",
  "Shenoy",
  "Upadhyay",
  "Das",
  "Dutta",
  "Ghosh",
  "Mukherjee",
  "Banerjee",
  "Chatterjee",
  "Sengupta",
  "Bhattacharya",
  "Chakraborty",
  "Roy",
  "Agrawal",
  "Arora",
  "Bajaj",
  "Batra",
  "Bhalla",
  "Chadha",
  "Dhawan",
  "Gaba",
  "Gulati",
  "Kalra",
  "Khanna",
  "Lamba",
  "Madan",
  "Nagpal",
  "Oberoi",
  "Punjabi",
  "Qureshi",
  "Rastogi",
  "Sabharwal",
  "Talwar",
  "Uppal",
  "Vohra",
  "Wadhwa",
  "Xavier",
  "Yadav",
  "Zaveri",
])

export const HONORIFICS = new Set([
  "Mr.",
  "Mr",
  "Mrs.",
  "Mrs",
  "Ms.",
  "Ms",
  "Miss",
  "Dr.",
  "Dr",
  "Prof.",
  "Prof",
  "Professor",
  "Sri",
  "Shri",
  "Smt.",
  "Smt",
  "Kumari",
  "Babu",
  "Ji",
])

export function levenshteinDistance(str1: string, str2: string): number {
  const matrix = Array(str2.length + 1)
    .fill(null)
    .map(() => Array(str1.length + 1).fill(null))

  for (let i = 0; i <= str1.length; i++) matrix[0][i] = i
  for (let j = 0; j <= str2.length; j++) matrix[j][0] = j

  for (let j = 1; j <= str2.length; j++) {
    for (let i = 1; i <= str1.length; i++) {
      const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1
      matrix[j][i] = Math.min(matrix[j][i - 1] + 1, matrix[j - 1][i] + 1, matrix[j - 1][i - 1] + indicator)
    }
  }
  return matrix[str2.length][str1.length]
}

export function jaroSimilarity(str1: string, str2: string): number {
  if (str1 === str2) return 1.0
  const len1 = str1.length
  const len2 = str2.length
  if (len1 === 0 || len2 === 0) return 0.0

  const matchWindow = Math.floor(Math.max(len1, len2) / 2) - 1
  if (matchWindow < 0) return 0.0

  const str1Matches = new Array(len1).fill(false)
  const str2Matches = new Array(len2).fill(false)
  let matches = 0
  let transpositions = 0

  for (let i = 0; i < len1; i++) {
    const start = Math.max(0, i - matchWindow)
    const end = Math.min(i + matchWindow + 1, len2)
    for (let j = start; j < end; j++) {
      if (str2Matches[j] || str1[i] !== str2[j]) continue
      str1Matches[i] = true
      str2Matches[j] = true
      matches++
      break
    }
  }

  if (matches === 0) return 0.0

  let k = 0
  for (let i = 0; i < len1; i++) {
    if (!str1Matches[i]) continue
    while (!str2Matches[k]) k++
    if (str1[i] !== str2[k]) transpositions++
    k++
  }

  return (matches / len1 + matches / len2 + (matches - transpositions / 2) / matches) / 3.0
}

export function jaroWinklerSimilarity(str1: string, str2: string): number {
  const jaroSim = jaroSimilarity(str1, str2)
  if (jaroSim < 0.7) return jaroSim

  let prefix = 0
  for (let i = 0; i < Math.min(str1.length, str2.length, 4); i++) {
    if (str1[i] === str2[i]) prefix++
    else break
  }
  return jaroSim + 0.1 * prefix * (1 - jaroSim)
}

export function similarityRatio(str1: string, str2: string): number {
  const maxLen = Math.max(str1.length, str2.length)
  if (maxLen === 0) return 1.0
  return 1 - levenshteinDistance(str1, str2) / maxLen
}

export function phoneticSimilarity(str1: string, str2: string): number {
  const phoneticConvert = (str: string): string => {
    return str
      .toLowerCase()
      .replace(/ph/g, "f")
      .replace(/th/g, "t")
      .replace(/ch/g, "c")
      .replace(/sh/g, "s")
      .replace(/kh/g, "k")
      .replace(/gh/g, "g")
      .replace(/bh/g, "b")
      .replace(/dh/g, "d")
      .replace(/v/g, "w")
      .replace(/y/g, "i")
      .replace(/[aeiou]/g, "")
  }

  const phonetic1 = phoneticConvert(str1)
  const phonetic2 = phoneticConvert(str2)
  return similarityRatio(phonetic1, phonetic2)
}

export function calculateSimilarityScore(original: string, candidate: string) {
  const orig = original.toLowerCase().trim()
  const cand = candidate.toLowerCase().trim()

  const metrics = {
    levenshtein: levenshteinDistance(orig, cand),
    jaro: jaroSimilarity(orig, cand),
    jaroWinkler: jaroWinklerSimilarity(orig, cand),
    similarity: similarityRatio(orig, cand),
    phonetic: phoneticSimilarity(orig, cand),
  }

  const score = metrics.jaroWinkler * 0.4 + metrics.similarity * 0.3 + metrics.phonetic * 0.2 + metrics.jaro * 0.1
  return { score, metrics }
}

export function findClosestMatch(name: string, dictionary: Set<string>, minSimilarity = 0.7) {
  if (!name || name.trim().length === 0) return null

  const cleanName = name.trim()
  let bestMatch = null
  let bestScore = 0
  let bestMetrics = null

  for (const dictName of dictionary) {
    if (dictName.toLowerCase() === cleanName.toLowerCase()) {
      return {
        match: dictName,
        score: 1.0,
        metrics: { levenshtein: 0, jaro: 1.0, jaroWinkler: 1.0, similarity: 1.0, phonetic: 1.0 },
      }
    }
  }

  for (const dictName of dictionary) {
    const { score, metrics } = calculateSimilarityScore(cleanName, dictName)
    const lengthDiff = Math.abs(cleanName.length - dictName.length)
    const maxLengthDiff = Math.max(2, Math.floor(cleanName.length * 0.3))

    if (lengthDiff > maxLengthDiff) continue
    if (metrics.levenshtein > Math.max(2, Math.floor(cleanName.length * 0.4))) continue

    if (score > bestScore && score >= minSimilarity) {
      bestScore = score
      bestMatch = dictName
      bestMetrics = metrics
    }
  }

  return bestMatch ? { match: bestMatch, score: bestScore, metrics: bestMetrics } : null
}
